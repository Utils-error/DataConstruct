首次提交时，需要使用关联本地仓库与远程GitHub仓库

# 其他
 1.拉取远程主分支并允许合并不相关历史 git命令（master为分支名）
git pull origin master --allow-unrelated-histories

# 数组 
1. 定义：数组是由一组元素（值或变量）组成的数据结构。
2.  java中数组结构  
[      markword     ]   对象头，存储信息（8字节）  
[class指针] [数组大小]  指向的类对象指针、数组最大容量均为4字节  
[   值    ] [  值2   ]  具体值，int类型4个字节（举例）  
[   值3   ] [对齐字节]  java中对象均为8字节整数倍，不足使用对齐字节补足
3. 动态数组基本结构  
(1) 成员变量： 默认容量 当前大小 静态数组  
(2) 插入方法：当插入位置为末尾时，可以直接添加；非末尾位置时，需要将当前位置后续元素右移  
(3) 遍历方法：
    随机访问：直接获取指定索引位置元素；
    foreach：使用函数式接口，accept方法执行调用处具体的实现方法
    iterator迭代器遍历：需要实现iterable接口，并使用匿名内部类Iterator重写hasNext与Next方法，增强for循环底层使用的是迭代器遍历
    stream流：Stream.of()方法，将静态数组传入即可，注意可遍历范围  
(4) 删除方法：当删除位置为末尾时，直接删除；非末尾位置时，则需要将当前位置后续元素左移

# 二维数组
## 内存结构
 可以看成一个外层数组，存储每一个数组的引用，内层数组存储具体值，在空间分布上是连续的。
## 局部性原理
  在CPU读取内容数据时，会读取一个缓存行的数据，那么在较大的数组遍历时，按照先行后列的顺序遍历效率较高，可以充分利用缓存 
  而如果采取先列后行，那么每次都需要加载缓存行，当缓存达到上限后，旧缓存将被覆盖。

# 链表
## 内存结构
数据元素的线性集合，存储不连续，可以分类为：单向链表、双向链表、循环链表
## 随机访问性能
只能依次遍历，时间复杂度O(n)
for循环、whlie循环、iterator迭代器
## 插入与删除
起始位置：O(1);结束位置：已知尾节点O(1),未知仍为O(n);中间位置:O(n),因为需要找到插入位置
## 带哨兵的链表
避免因初始空链表而进行的空判断，简化代码

## 双向链表
由于在头尾各维护了一个指针，因此在进行操作时有两个地方需要注意：
(1) 在进行节点修改时，需要同时修改next和prev两个指针；
(2) 在进行尾部相关操作时，由于尾部节点已知可以进行快速操作，无须再遍历。

## 环形链表

# 递归
通过解决同类问题的更小子集作为解决方案，需要明确父问题与子问题的关系   
递归本质是隐式栈，需要在方法体中给出递归出口

## 尾调用与尾递归
a(){
// 其他代码
return b();
}
即最后一步操作为调用其他方法，如果是调用自己，那么就是尾递归。某些编译器(c/scara)  
会对这种代码做优化，可以同时调用a()与b(),使得a可以提前释放内存资源，而无须等待b。

## Master theorem主定理 计算递归时间复杂度
$T(n) = aT(\frac{n}{b})+f(n)$  
其中，a为子问题个数，b为子问题数据规模缩小倍数，具体计算结果为，考虑$x = log_b(a)$ ,$c$ 为 $f(n)$的中n的指数  
(1)当$x>c$,$T(n) =O(n^x)$;  
(2)当$c>x$,$T(n) =O(n^c)$;  
(3)当$x=c$,$T(n) =O(n^xlog n)$

当然，并不是所有的递归都可以由主定理计算得到，此时，就需要依据递归式进行推导。  
以斐波那契数列的递归实现为例，$T(n) = T(n-1) + T(n-2)$,那么就不符合主定理，因此需要依次递推.

## 常见链表算法
龟兔赛跑（Floyd判圈算法）判别链表中是否存在环   
递归求解  

## 常见排序算法
冒泡排序：左无序，右有序，左边比较相邻元素，使较大数向右移动，成为有序，O(n^2)
插入排序：左有序，右无序，遍历右侧元素插入到左侧有序序列中，O(n^2)
归并排序: 采用分治的思想，分：将一个无序数组不断拆分，直到子数组仅有一个元素（最小的有序表），治：将子数组按照顺序进行合并。  

## 队列
队列是以顺序方式维护的一组数据集合，从一端（尾）添加数据，从另一端（头）移除数据。  

# 实现方式  
(1) 基于链表实现(2)基于循环数组实现

当 被除数/除数，除数为2的n次幂时，其结果有显著规律：即被除数的后n位为余数，被除数右移n位为则为商  
那么如何获得被移除的余数呢，通过按位与求得：即余数mod = 被除数 & (2^n-1),商 = 被除数 >> n;  

这就要求必须有一个2的n次幂数，当入参不满足时，如何迅速的扩大到最近的2的n次幂数，可以使用扩散法。


